% SLRECON Implements "Structured Lighting" post-processing.
%    SLPROCESS implements an inexpensive 3D photography system
%    using binary and Gray-coded structured lighting.
%
%    This script can be used to reconstruct captured sequences 
%    generated by our reference implementation. Please read the 
%    SIGGRAPH 2009 course notes for additional details.
% 
% Kai Wu
% University of British Columbia
% 1 Sep 2017

% Add required subdirectories.
addpath('utilities');

% Reset Matlab environment.
clear, clc, close all;

% Set structured lighting parameters.
obj_name     = 'beethovan';    % object name (should correspond to a data dir.)
data_dir     = sprintf('data/%s', obj_name);
data_fmt     = 'jpg';
calib_dir    = sprintf('calib/calib_cam_proj_%s', obj_name);
seq_type     = 'Gray';   % structured light sequence type ('Gray' or 'bin')
minContrast  = 0.2;
maxContrast  = 0.5;

% Set projector parameters
proj_dsample = 1; % downsampling factor (i.e., min. system resolution)
proj_value   = 255;     % Gray code intensity
proj_width   = 1024;
proj_height  = 768;

% Set reconstruction parameters.
plot_dsample = 100;      % down-sampling rate for Matlab point cloud display
distReject  = Inf;      % rejection distance (for outlier removal)

% Set visualization parameters
is_vis = false;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Part I: Decode Grey code sequence to recover illumination plane(s).

% Load calibration data.
load(calib_dir);
if (~exist('Nc', 'var'))
    slCalib;
end

% Display prompt to begin scanning.
clc; disp('[Reconstruction of Structured Light Sequences]');

% Determine number of cameras and image resolution(s).
disp('+ Extracting data set properties...');
ncams = 1;
npatterns = cell(1,ncams);
dim_cam = cell(1,ncams);
for icam = 1:ncams
   npatterns{icam} = ((length(dir(data_dir))-2)-2)/4; % allone, allzero, ./, ../
   I = imread(sprintf('%s/0000.%s', data_dir, data_fmt));
   dim_cam{icam} = [size(I,1) size(I,2)];
end

% Generate vertical and horizontal Gray code stripe patterns.
% Note: pattern{i} contains the Gray code pattern for "orientation" (column/row) i.
%       offset(i) is the integer column/row offset for pattern{i}.
%       img_pattern_ref{ii}{icam} is the reference image for camera icam
%       img_pattern1{i, j}{icam} is the j-th imaged pattern for "orientation" (column/row) i and camera icam
%       img_pattern2{i, j}{icam} is the inverse of the j-th imaged pattern for "orientation" (column/row) i and camera icam
disp('+ Regenerating structured light sequence...');
if strcmp(seq_type,'Gray')
   [pattern,offset] = graycode(proj_width/proj_dsample, proj_height/proj_dsample);
else
   [pattern,offset] = bincode(proj_width/proj_dsample, proj_height/proj_dsample);
end

% Load captured structured lighting sequences.
disp('+ Loading data set...');
for icam = 1:ncams
   if ~exist(data_dir,'dir')
      error([data_dir, obj_name,'_',seq_type,' is not available!']);
   end
   ind_img = 0;
   for i = 1:2 % column/row pattern
      for j = 1:npatterns{icam} % index of bitplane
         img_pattern1{i, j}{icam} = imread(sprintf('%s/%04d.%s', data_dir, ind_img, data_fmt));
         ind_img = ind_img + 1;
         img_pattern2{i, j}{icam} = imread(sprintf('%s/%04d.%s', data_dir, ind_img, data_fmt));
         ind_img = ind_img + 1;
      end
   end
   % last two are allone, allzero
   img_pattern_ref{1}{icam} = imread(sprintf('%s/%04d.%s', data_dir, 40, data_fmt));
   img_pattern_ref{2}{icam} = imread(sprintf('%s/%04d.%s', data_dir, 41, data_fmt));
end

% Estimate column/row label for each pixel (i.e., decode Gray codes).
% Note: est_pattern{j,k} is the estimated Gray code for "orientation" j and camera k.
%       est_code{j,k} is the integer column/row estimate.
%       est_mask{j,k} is the per-pixel mask (i.e., pixels with enough contrast).
disp('+ Recovering projector rows/columns from structured light sequence...');
est_pattern = cell(size(img_pattern1,1),ncams);
est_code = cell(size(img_pattern1,1),ncams);
est_mask = cell(size(img_pattern1,1),ncams);
C = inv([1.0 0.956 0.621; 1.0 -0.272 -0.647; 1.0 -1.106 1.703]);
C = C(1,:)';

prct = 98;
for icam = 1:ncams
    gray_allone = imlincomb(C(1), img_pattern_ref{1}{icam}(:, :, 1),...
                           C(2), img_pattern_ref{1}{icam}(:, :, 2),...
                           C(3), img_pattern_ref{1}{icam}(:, :, 3),'double');
    gray_allzero = imlincomb(C(1), img_pattern_ref{2}{icam}(:, :, 1),...
                            C(2), img_pattern_ref{2}{icam}(:, :, 2),...
                            C(3), img_pattern_ref{2}{icam}(:, :, 3),'double');
    % grayAllOne_thresh = prctile(gray_allone(:), prct);
    % grayAllZero_thresh = prctile(gray_allzero(:), prct);
    % grayContrast_thresh = grayAllOne_thresh - grayAllZero_thresh;
    grayContrast = abs(gray_allone - gray_allzero);
    grayContrast_thresh = prctile(grayContrast(:), prct);
                    
    for j = 1:size(img_pattern1,1) % column/row pattern
      est_pattern{j,icam} = zeros(size(img_pattern_ref{1}{1},1),size(img_pattern_ref{1}{1},2),size(img_pattern1,2),'uint8');
      est_mask{j,icam} = false(size(img_pattern_ref{1}{1},1),size(img_pattern_ref{1}{1},2));
      for i = 1:size(img_pattern1,2) % index of bitplane

         % Convert image pair to grayscale.
         gimg_pattern1 = imlincomb(C(1),img_pattern1{j,i}{icam}(:,:,1),...
                           C(2),img_pattern1{j,i}{icam}(:,:,2),...
                           C(3),img_pattern1{j,i}{icam}(:,:,3),'double');
         gimg_pattern2 = imlincomb(C(1),img_pattern2{j,i}{icam}(:,:,1),...
                           C(2),img_pattern2{j,i}{icam}(:,:,2),...
                           C(3),img_pattern2{j,i}{icam}(:,:,3),'double');

         % Eliminate all pixels that do not exceed contrast threshold.
         gimg_pattern = abs(gimg_pattern1 - gimg_pattern2);
         grayAB_thresh = prctile(gimg_pattern(:), prct);
         gimg_pattern = gimg_pattern ./ grayAB_thresh .* grayContrast_thresh;
         est_mask{j,icam}(gimg_pattern > maxContrast * grayContrast_thresh) = true;
         imshow(est_mask{j,icam});

         % Estimate current bit of Gray code from image pair.
         bitPlane = zeros(size(img_pattern_ref{1}{1},1),size(img_pattern_ref{1}{1},2),'uint8');
         bitPlane(gimg_pattern1(:,:) >= gimg_pattern2(:,:)) = 1;
         est_pattern{j,icam}(:,:,i) = bitPlane;
      end
      if strcmp(seq_type,'Gray')
         est_code{j,icam} = gray2dec(est_pattern{j,icam})-offset(j);
      else
         est_code{j,icam} = bin2dec(est_pattern{j,icam})-offset(j);
      end
      est_code{j,icam}(~est_mask{j,icam}) = NaN;
    end
end
close 1, clear img_pattern1 img_pattern2 est_pattern gimg_pattern1 gimg_pattern2 bitPlane;

% Eliminate invalid column/row estimates.
% Note: This will exclude pixels if either the column or row is missing.
%       est_code{j,k} is the column/row for "orientation" j and camera k.
%       mask{k} is the overal per-pixel mask for camera k.
mask = cell(1,ncams);
for icam = 1:ncams
    mask{icam} = est_mask{1,icam};
    for j = 1:size(est_code,1)
      if j == 1
         est_code{j,icam}(est_code{j,icam} > proj_width) = NaN;
      else
         est_code{j,icam}(est_code{j,icam} > proj_height) = NaN;
      end
      est_code{j,icam}(est_code{j,icam} < 1) = NaN;
      for i = 1:size(est_code,1)
         est_code{j,icam}(~est_mask{i,icam}) = NaN;
         mask{icam} =  mask{icam} & est_mask{i,icam};
      end
    end
end

% Display recovered projector column/row.
figure(1); clf;
imagesc(est_code{1,1}); axis image; colormap(jet(256));
title('Recovered Projector Column Indices'); drawnow;
figure(2); clf;
imagesc(est_code{2,1}); axis image; colormap(jet(256));
title('Recovered Projector Row Indices'); drawnow;
figure(3); clf;
imagesc(img_pattern_ref{1}{1}); axis image; colormap(jet(256));
title('Reference Image for Texture Mapping'); drawnow;
fprintf('number of pixel: %d, %d\n', sum(sum(~isnan(est_code{1, 1}))), sum(sum(~isnan(est_code{2, 1}))));


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Part II: Reconstruct surface using line-plane intersection.

% Reconstruct 3D points using intersection with illumination plane(s).
% Note: Reconstructs from all cameras in the first camera coordinate system.
vertices = cell(1,length(Nc));
colors   = cell(1,length(Nc));
disp('+ Reconstructing 3D points...');
for i = 1:length(Nc)
   idx       = find(~isnan(est_code{1,i}) & ~isnan(est_code{2,i}));
   [row,col] = ind2sub(size(est_code{1,i}),idx);
   npts      = length(idx);
   colors{i} = 0.65*ones(npts,3);
   Rc        = im2double(img_pattern_ref{1}{i}(:,:,1));
   Gc        = im2double(img_pattern_ref{1}{i}(:,:,2));
   Bc        = im2double(img_pattern_ref{1}{i}(:,:,3));
   vV = intersect_line_plane(repmat(Oc{i},1,npts),Nc{i}(:,idx),wPlaneCol(est_code{1,i}(idx),:)');
   vH = intersect_line_plane(repmat(Oc{i},1,npts),Nc{i}(:,idx),wPlaneRow(est_code{2,i}(idx),:)');
   vertices{i} = vV';
   rejectIdx = find(sqrt(sum((vV-vH).^2)) > distReject);
   vertices{i}(rejectIdx,1) = NaN;
   vertices{i}(rejectIdx,2) = NaN;
   vertices{i}(rejectIdx,3) = NaN;
   colors{i}(:,1) = Rc(idx);
   colors{i}(:,2) = Gc(idx);
   colors{i}(:,3) = Bc(idx);
end

% Reconstruct 3D points using non-linear triangulation.
% Note: Reconstructs from all cameras in the first camera coordinate system.
for i = 1:ncams
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Part III: Display reconstruction results and export PLY model.

% Display result.
disp('+ Displaying results and exporting PLY model...');

% Display project/camera calibration results.
% Display the recovered 3D point cloud (with per-vertex color).
% Note: Convert to indexed color map for use with FSCATTER3.
if (is_vis)
    disp_calib;
    for i = 1:length(Nc)
       C = reshape(colors{i},[size(colors{i},1) 1 size(colors{i},2)]);
       [C,cmap] = rgb2ind(C,256);
       hold on;
          fscatter3(vertices{i}(1:plot_dsample:end,1),...
                    vertices{i}(1:plot_dsample:end,3),...
                   -vertices{i}(1:plot_dsample:end,2),...
                    double(C(1:plot_dsample:end)),cmap);
       hold off;
       axis tight; drawnow;
    end
end

% Export colored point cloud as a PLY file.
clear idx; mergedVertices = []; mergedColors = [];
for i = 1:length(Nc)
   idx{i} = find(~isnan(vertices{i}(:,1)));
   tmp = Rc_1_cam{i}' * (vertices{i}(idx{i}, :)' - repmat(Tc_1_cam{i}, 1, numel(idx{i}))); % transform to world coordinate system
   tmp = tmp';
   writePly([data_dir, '/', obj_name, '_', algs{aa}, '.ply'], tmp(:,[1 2 3]),colors{i}(idx{i},:));
   mergedVertices = [mergedVertices; vertices{i}(idx{i},[1 2 3])];
   mergedColors = [mergedColors; colors{i}(idx{i},:)];
end
if length(Nc) > 1
   vrmlPoints(['./data/',seq_type,'/',obj_name,'/merged.wrl'],...
      mergedVertices,mergedColors);
end
disp(' ');

rmpath('utilities');
